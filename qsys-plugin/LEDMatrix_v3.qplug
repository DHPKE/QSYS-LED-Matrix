-- Q-SYS LED Matrix Controller Plugin
-- Version 4.0.0 - Added portrait/landscape orientation control
-- Controls RPi Zero 2 W 64x32 LED Matrix via UDP (JSON format)
--
-- FIRMWARE PROTOCOL (JSON over UDP):
--   {"cmd":"text","seg":0,"text":"Hello","color":"FFFFFF","bgcolor":"000000",
--    "font":"arial","size":"auto","align":"C","effect":"none","intensity":255}
--   {"cmd":"clear","seg":0}  |  {"cmd":"clear_all"}
--   {"cmd":"brightness","value":200}
--   {"cmd":"orientation","value":"landscape"}  -- "landscape" or "portrait"
--   {"cmd":"layout","preset":N}   -- N = 1..7 or 11..14
--
-- LAYOUT PRESETS:
--   1  = Fullscreen
--   2  = Top / Bottom halves
--   3  = Left / Right halves
--   4  = Triple Left  (left half | right-top qtr | right-bottom qtr)
--   5  = Triple Right (left-top qtr | left-bottom qtr | right half)
--   6  = Thirds       (21px | 21px | 22px columns)
--   7  = Quad View
--   11 = Fullscreen Segment 1 only
--   12 = Fullscreen Segment 2 only
--   13 = Fullscreen Segment 3 only
--   14 = Fullscreen Segment 4 only

PluginInfo = {
    Name = "PKE~LED Matrix Display",
    Version = "4.0.0",
    Id = "dhpke.olimex.led.matrix.4.0.0",
    Description = "RPi 64x32 LED Matrix - portrait/landscape orientation, 7+4 presets",
    ShowDebug = true,
    Author = "DHPKE"
}

function GetProperties()
    return {
        { Name = "IP Address", Type = "string",  Value = "192.168.1.100" },
        { Name = "UDP Port",   Type = "integer", Min = 1, Max = 65535, Value = 21324 }
    }
end

function GetControls(props)
    local controls = {}

    -- Connection
    table.insert(controls, { Name="ip_address",        ControlType="Text",      Count=1, UserPin=true, PinStyle="Input"  })
    table.insert(controls, { Name="udp_port",          ControlType="Text",      Count=1, UserPin=true, PinStyle="Input"  })
    table.insert(controls, { Name="reconnect",         ControlType="Button",    ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input"  })
    table.insert(controls, { Name="connection_status", ControlType="Indicator", IndicatorType="Status", Count=1, UserPin=true, PinStyle="Output" })
    table.insert(controls, { Name="last_command",      ControlType="Text",      Count=1, UserPin=true, PinStyle="Output" })

    -- Layout preset: Text control (populated as ComboBox at runtime)
    table.insert(controls, { Name="layout_preset", ControlType="Text", Count=1, UserPin=true, PinStyle="Both" })
    table.insert(controls, { Name="apply_layout",  ControlType="Button", ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input" })

    -- Segment controls (seg1 .. seg4)
    for seg = 0, 3 do
        local n = seg + 1
        table.insert(controls, { Name=string.format("seg%d_text",       n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_text_color", n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_bg_color",   n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_align",      n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_effect",     n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_font",       n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, { Name=string.format("seg%d_size",       n), ControlType="Text",    Count=1, UserPin=true, PinStyle="Both" })
        table.insert(controls, {
            Name=string.format("seg%d_intensity", n),
            ControlType="Knob", ControlUnit="Integer", Min=0, Max=255,
            Count=1, UserPin=true, PinStyle="Both"
        })
        table.insert(controls, { Name=string.format("seg%d_send",   n), ControlType="Button", ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input" })
        table.insert(controls, { Name=string.format("seg%d_clear",  n), ControlType="Button", ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input" })
        table.insert(controls, { Name=string.format("seg%d_invert", n), ControlType="Button", ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input" })
        table.insert(controls, {
            Name=string.format("seg%d_active", n),
            ControlType="Indicator", IndicatorType="LED",
            Count=1, UserPin=true, PinStyle="Output"
        })
    end

    -- Global
    table.insert(controls, {
        Name="brightness", ControlType="Knob", ControlUnit="Integer",
        Min=0, Max=255, Count=1, UserPin=true, PinStyle="Both"
    })
    table.insert(controls, { Name="orientation", ControlType="Text", Count=1, UserPin=true, PinStyle="Both" })
    table.insert(controls, { Name="clear_all", ControlType="Button", ButtonType="Trigger", Count=1, UserPin=true, PinStyle="Input" })

    return controls
end

function GetControlLayout(props)
    local layout   = {}
    local graphics = {}

    local W  = 600    -- total plugin width
    local CH = 24     -- standard control height
    local BH = 28     -- button height

    local C_GRP   = {62,  62,  62 }
    local C_LBL   = {205, 205, 205}
    local C_BTN_G = {0,   148, 55 }
    local C_BTN_R = {165, 38,  38 }
    local C_BTN_B = {45,  105, 195}
    local C_BTN_O = {200, 110, 0  }

    local function GBox(x, y, w, h, title)
        table.insert(graphics, {
            Type="GroupBox", Text=title or "", Fill=C_GRP,
            StrokeWidth=1, CornerRadius=4,
            Position={x, y}, Size={w, h}
        })
    end
    local function Lbl(text, x, y, w)
        table.insert(graphics, {
            Type="Text", Text=text, Font="Roboto", FontSize=9,
            HTextAlign="Left", Color=C_LBL,
            Position={x, y}, Size={w, 12}
        })
    end

    -- ── Title bar ──────────────────────────────────────────────────
    table.insert(graphics, {
        Type="GroupBox", Text="", Fill={38,38,38},
        StrokeWidth=0, CornerRadius=5,
        Position={0,0}, Size={W,36}
    })
    table.insert(graphics, {
        Type="Text", Text="LED Matrix Controller  v3.14.0",
        Font="Roboto", FontSize=14, FontStyle="Bold",
        HTextAlign="Center", Color={255,255,255},
        Position={0,9}, Size={W,20}
    })

    -- ── Connection ─────────────────────────────────────────────────
    local y = 42
    GBox(0, y, W, 54, "Connection")
    Lbl("IP Address",    6,   y+5, 124)
    Lbl("Port",        138,   y+5,  62)
    Lbl("Status",      278,   y+5,  62)
    Lbl("Last Command",348,   y+5, W-354)
    layout["ip_address"]        = { PrettyName="Conn~IP",       Style="Text",      Position={6,   y+18}, Size={124,   CH} }
    layout["udp_port"]          = { PrettyName="Conn~Port",     Style="Text",      Position={138, y+18}, Size={62,    CH} }
    layout["reconnect"]         = { PrettyName="Conn~Reconnect", Style="Button",   ButtonStyle="Trigger", Legend="Reconnect", Color=C_BTN_B, Position={208, y+18}, Size={62, BH} }
    layout["connection_status"] = { PrettyName="Conn~Status",   Style="Indicator", Position={278, y+18}, Size={62,    CH} }
    layout["last_command"]      = { PrettyName="Conn~LastCmd",  Style="Text",      Position={348, y+18}, Size={W-354, CH} }

    -- ── Display Layout ──────────────────────────────────────────────
    -- Layout:
    --   y+6  : thumbnail row   (TH=26 px tall)
    --   y+32 : thumbnail labels (10 px)
    --   y+44 : "Layout Preset" label (12 px)
    --   y+58 : ComboBox + Apply button (24 px)
    --   Total inner height = 58+24+8 = 90  →  GBox height = 96
    --
    -- 7 thumbnails: TW=62, gap=6  → 7*(62+6)-6 = 470 px  (fits in W=600)
    -- All pixel offsets are explicit integers — no division operators.
    y = y + 60
    GBox(0, y, W, 96, "Display Layout")

    local TW  = 62   -- thumbnail width
    local TH  = 26   -- thumbnail height
    local GAP = 6    -- gap between thumbnails
    local TX  = 6    -- left start x

    -- Helper: draw one coloured rectangle inside a thumbnail
    local function TRect(col, x, gy, w, h)
        table.insert(graphics, {
            Type="GroupBox", Text="", Fill=col,
            StrokeWidth=0, CornerRadius=0,
            Position={x, gy}, Size={w, h}
        })
    end

    -- Thumbnail outer borders + labels
    local thumbLabels = {"1 Full","2 Top/Bot","3 L/R","4 Tri-L","5 Tri-R","6 Thirds","7 Quad"}
    for i = 0, 6 do
        local tx = TX + i*(TW+GAP)
        local ty = y + 6
        -- dark background
        table.insert(graphics, {Type="GroupBox", Text="", Fill={18,18,18},
            StrokeWidth=1, CornerRadius=2, Position={tx,ty}, Size={TW,TH}})
        -- label below
        table.insert(graphics, {Type="Text", Text=thumbLabels[i+1],
            Font="Roboto", FontSize=7, HTextAlign="Center", Color=C_LBL,
            Position={tx, ty+TH+2}, Size={TW, 10}})
    end

    -- Colour palette for segments
    local cA = {70, 160,  80}   -- green   seg 0
    local cB = {70,  80, 160}   -- blue    seg 1
    local cC = {160, 70,  70}   -- red     seg 2
    local cD = {160,160,  40}   -- yellow  seg 3

    -- Precalculated halves (TW=62 → 31; TH=26 → 13; TW/3=20,20,22; TH/4 not needed)
    local HW = 31   -- half width
    local HH = 13   -- half height
    local T1 = 20   -- first third width
    local T2 = 20   -- second third width
    local T3 = 22   -- third third width  (T1+T2+T3 = 62 ✓)

    -- Preset 1 — Fullscreen (single colour fills whole thumb)
    do local tx=TX+0*(TW+GAP); local ty=y+6
        TRect(cA, tx, ty, TW, TH)
    end
    -- Preset 2 — Top/Bottom
    do local tx=TX+1*(TW+GAP); local ty=y+6
        TRect(cA, tx,    ty,    TW, HH)
        TRect(cB, tx,    ty+HH, TW, HH)
    end
    -- Preset 3 — Left/Right
    do local tx=TX+2*(TW+GAP); local ty=y+6
        TRect(cA, tx,    ty, HW, TH)
        TRect(cB, tx+HW, ty, HW, TH)
    end
    -- Preset 4 — Triple Left (left half | right-top | right-bottom)
    do local tx=TX+3*(TW+GAP); local ty=y+6
        TRect(cA, tx,    ty,    HW, TH)
        TRect(cB, tx+HW, ty,    HW, HH)
        TRect(cC, tx+HW, ty+HH, HW, HH)
    end
    -- Preset 5 — Triple Right (left-top | left-bottom | right half)
    do local tx=TX+4*(TW+GAP); local ty=y+6
        TRect(cA, tx,    ty,    HW, HH)
        TRect(cB, tx,    ty+HH, HW, HH)
        TRect(cC, tx+HW, ty,    HW, TH)
    end
    -- Preset 6 — Thirds
    do local tx=TX+5*(TW+GAP); local ty=y+6
        TRect(cA, tx,       ty, T1, TH)
        TRect(cB, tx+T1,    ty, T2, TH)
        TRect(cC, tx+T1+T2, ty, T3, TH)
    end
    -- Preset 7 — Quad
    do local tx=TX+6*(TW+GAP); local ty=y+6
        TRect(cA, tx,    ty,    HW, HH)
        TRect(cB, tx+HW, ty,    HW, HH)
        TRect(cC, tx,    ty+HH, HW, HH)
        TRect(cD, tx+HW, ty+HH, HW, HH)
    end

    -- ComboBox + Apply button
    Lbl("Layout Preset  (1-7, 11-14)", TX, y+44, 210)
    layout["layout_preset"] = {
        PrettyName="Layout~Preset",
        Style="ComboBox", IsReadOnly=false,
        Position={TX, y+58}, Size={220, CH}
    }
    layout["apply_layout"] = {
        PrettyName="Layout~Apply",
        Style="Button", ButtonStyle="Trigger",
        Legend="Apply Layout", Color=C_BTN_O,
        Position={234, y+58}, Size={160, CH}
    }

    -- ── Segment rows ────────────────────────────────────────────────
    -- Each segment GroupBox contains:
    --   Row 1 at +20: Active LED | Text field | [Display][Invert][Clear] buttons
    --   Row 2 at +54: 6 ComboBoxes with labels above (height 24px, ends at sy+78)
    --   Row 3 at +96: Intensity fader (label at sy+81, 3px gap after ComboBoxes)
    --   GroupBox height = 96 + 22 + 4 = 122
    y = y + 118
    local SEG_H = 122

    -- 6 combo columns: widths must sum to W-12 minus 5 gaps of 6px
    -- W=600: W-12=588; 5 gaps=30; net=558
    -- 110+110+82+66+76+114 = 558 ✓
    local comboCols = {
        {"Text Color", "text_color", "TxtColor", 110},
        {"BG Color",   "bg_color",   "BgColor",  110},
        {"Font",       "font",       "Font",      82},
        {"Size",       "size",       "Size",      66},
        {"Align",      "align",      "Align",     76},
        {"Effect",     "effect",     "Effect",   114},
    }

    for seg = 0, 3 do
        local n   = seg + 1
        local sn  = "seg"..n.."_"
        local grp = "Seg"..n
        local sy  = y + seg * (SEG_H + 4)

        GBox(0, sy, W, SEG_H, grp)

        -- Row 1
        local r1 = sy + 20
        layout[sn.."active"] = { PrettyName=grp.."~Active", Style="Led",
            Position={6, r1+5}, Size={14, 14} }
        Lbl("Text", 26, r1-12, W-330)
        layout[sn.."text"]   = { PrettyName=grp.."~Text",   Style="Text",
            Position={26, r1}, Size={W-332, CH} }
        layout[sn.."send"]   = { PrettyName=grp.."~Send",   Style="Button",
            ButtonStyle="Trigger", Legend="Display", Color=C_BTN_G,
            Position={W-300, r1}, Size={94, BH} }
        layout[sn.."invert"] = { PrettyName=grp.."~Invert", Style="Button",
            ButtonStyle="Trigger", Legend="Invert",  Color=C_BTN_B,
            Position={W-200, r1}, Size={94, BH} }
        layout[sn.."clear"]  = { PrettyName=grp.."~Clear",  Style="Button",
            ButtonStyle="Trigger", Legend="Clear",   Color=C_BTN_R,
            Position={W-100, r1}, Size={94, BH} }

        -- Row 2: 6 ComboBoxes
        local r2 = sy + 54
        local cx = 6
        for _, col in ipairs(comboCols) do
            Lbl(col[1], cx, r2-15, col[4])
            layout[sn..col[2]] = { PrettyName=grp.."~"..col[3], Style="ComboBox",
                IsReadOnly=false,
                Position={cx, r2}, Size={col[4], CH} }
            cx = cx + col[4] + 6
        end

        -- Row 3: Intensity fader
        local r3 = sy + 96
        Lbl("Intensity  (0=off  255=full)", 6, r3-15, 260)
        layout[sn.."intensity"] = { PrettyName=grp.."~Intensity", Style="Fader",
            Position={6, r3}, Size={W-14, 22} }
    end

    -- ── Global Controls ─────────────────────────────────────────────
    y = y + 4 * (SEG_H + 4) + 4
    GBox(0, y, W, 74, "Global Controls")
    Lbl("Brightness", 6, y+16, 80)
    layout["brightness"] = { PrettyName="Global~Bright",   Style="Fader",
        Position={6, y+30}, Size={220, 36} }
    Lbl("Orientation", 232, y+16, 100)
    layout["orientation"] = { PrettyName="Global~Orient", Style="ComboBox",
        Position={232, y+30}, Size={122, 36} }
    layout["clear_all"]  = { PrettyName="Global~ClearAll", Style="Button",
        ButtonStyle="Trigger", Legend="Clear All Segments", Color=C_BTN_R,
        Position={360, y+18}, Size={W-366, 36} }

    return layout, graphics
end

-- ══════════════════════════════════════════════════════════════════
-- Runtime
-- ══════════════════════════════════════════════════════════════════
if Controls then
    local socket   = nil
    local ip_addr  = Properties["IP Address"].Value
    local udp_port = Properties["UDP Port"].Value

    local activeLayoutSegments = {}
    local debounceTimers = {}

    -- ── Lookup tables ──────────────────────────────────────────────
    local ColorNames = {
        ["White"]   = "FFFFFF", ["Red"]     = "FF0000", ["Lime"]    = "00FF00",
        ["Blue"]    = "0000FF", ["Yellow"]  = "FFFF00", ["Magenta"] = "FF00FF",
        ["Cyan"]    = "00FFFF", ["Orange"]  = "FFA500", ["Purple"]  = "800080",
        ["Green"]   = "008000", ["Gold"]    = "FFD700",
        ["Gray"]    = "808080", ["Black"]   = "000000"
    }
    local FontMap  = { ["Arial"]="arial", ["Verdana"]="verdana", ["Digital"]="digital12", ["Mono"]="mono9" }
    local AlignMap = { ["Left"]="L", ["Center"]="C", ["Right"]="R" }

    -- ── Layout preset definitions ──────────────────────────────────
    -- Presets 1-7 use the RPi's built-in {"cmd":"layout","preset":N} handler.
    -- Presets 11-14 also send {"cmd":"layout","preset":N} — the RPi must
    -- handle those by mapping single-segment fullscreen via its own table
    -- (see config.py / udp_handler.py). Active-segment list here drives
    -- the Q-SYS LED indicators and auto-send after layout apply.
    local LayoutPresets = {
        [1]  = { name="1 - Fullscreen",           activeSegments={0},       preset=1  },
        [2]  = { name="2 - Top / Bottom",          activeSegments={0,1},     preset=2  },
        [3]  = { name="3 - Left / Right",          activeSegments={0,1},     preset=3  },
        [4]  = { name="4 - Triple Left",           activeSegments={0,1,2},   preset=4  },
        [5]  = { name="5 - Triple Right",          activeSegments={0,1,2},   preset=5  },
        [6]  = { name="6 - Thirds",                activeSegments={0,1,2},   preset=6  },
        [7]  = { name="7 - Quad View",             activeSegments={0,1,2,3}, preset=7  },
        [11] = { name="11 - Fullscreen Seg 1",     activeSegments={0},       preset=11 },
        [12] = { name="12 - Fullscreen Seg 2",     activeSegments={1},       preset=12 },
        [13] = { name="13 - Fullscreen Seg 3",     activeSegments={2},       preset=13 },
        [14] = { name="14 - Fullscreen Seg 4",     activeSegments={3},       preset=14 },
    }

    local LayoutNameToKey = {}
    for k, v in pairs(LayoutPresets) do LayoutNameToKey[v.name] = k end

    local LayoutChoices = {
        "1 - Fullscreen",
        "2 - Top / Bottom",
        "3 - Left / Right",
        "4 - Triple Left",
        "5 - Triple Right",
        "6 - Thirds",
        "7 - Quad View",
        "11 - Fullscreen Seg 1",
        "12 - Fullscreen Seg 2",
        "13 - Fullscreen Seg 3",
        "14 - Fullscreen Seg 4",
    }

    -- ── Helpers ────────────────────────────────────────────────────
    local function Debounce(key, delay, fn)
        if debounceTimers[key] then debounceTimers[key]:Stop() end
        if not debounceTimers[key] then debounceTimers[key] = Timer.New() end
        local t = debounceTimers[key]
        t.EventHandler = function() t:Stop(); fn() end
        t:Start(delay)
    end

    local function ReopenSocket()
        if socket then pcall(function() socket:Close() end) end
        local ok, err = pcall(function()
            socket = UdpSocket.New()
            socket:Open()
        end)
        if ok then
            Controls.connection_status.Value = 0
            print("✓ UDP socket ready -> " .. ip_addr .. ":" .. tostring(udp_port))
        else
            Controls.connection_status.Value = 2
            print("✗ Socket error: " .. tostring(err))
        end
    end

    local function ValidatePort(port)
        local num = tonumber(port)
        if num and num >= 1 and num <= 65535 then return num end
        return nil
    end

    -- Minimal JSON serialiser (no external library needed)
    local function jsonStr(v)
        if v == nil then return "null" end
        if type(v) == "number"  then return tostring(math.floor(v)) end
        if type(v) == "boolean" then return v and "true" or "false" end
        v = tostring(v):gsub('\\','\\\\'):gsub('"','\\"')
        return '"' .. v .. '"'
    end
    local function buildJson(t)
        local parts = {}
        for k, v in pairs(t) do
            table.insert(parts, jsonStr(k) .. ":" .. jsonStr(v))
        end
        return "{" .. table.concat(parts, ",") .. "}"
    end

    local function SendCommand(json)
        if not socket then
            Controls.connection_status.Value = 2
            Controls.last_command.String = "ERROR: No socket"
            return false
        end
        local ok, err = pcall(function() socket:Send(ip_addr, udp_port, json .. "\n") end)
        if ok then
            Controls.last_command.String = json
            Controls.connection_status.Value = 0
            print("-> " .. json)
            return true
        else
            Controls.last_command.String = "ERROR: " .. tostring(err)
            Controls.connection_status.Value = 2
            print("✗ Send error: " .. tostring(err))
            return false
        end
    end

    local function BuildTextCommand(seg)
        local s     = "seg" .. (seg+1) .. "_"
        local text    = Controls[s.."text"].String
        local color   = ColorNames[Controls[s.."text_color"].String] or "FFFFFF"
        local bgcolor = ColorNames[Controls[s.."bg_color"].String]   or "000000"
        local font    = FontMap[Controls[s.."font"].String]          or "arial"
        local size    = Controls[s.."size"].String                   or "auto"
        local align   = AlignMap[Controls[s.."align"].String]        or "C"
        local effect  = Controls[s.."effect"].String                 or "none"
        local intens  = math.floor(Controls[s.."intensity"].Value)
        return text, buildJson({
            cmd="text", seg=seg, text=text, color=color, bgcolor=bgcolor,
            font=font, size=size, align=align, effect=effect, intensity=intens
        })
    end

    -- ── Initialize ──────────────────────────────────────────────────
    local function Initialize()
        print("=== LED Matrix v4.0.0 Initializing ===")
        
        -- Always set IP/port from Properties
        if Controls.ip_address.String == "" then
            Controls.ip_address.String = ip_addr
        end
        if Controls.udp_port.String == "" then
            Controls.udp_port.String = tostring(udp_port)
        end
        
        -- Set choices (always needed)
        Controls.orientation.Choices = {"landscape", "portrait"}
        Controls.layout_preset.Choices = LayoutChoices
        
        -- Only set defaults if empty (first run)
        if Controls.orientation.String == "" then
            Controls.orientation.String = "landscape"
        end
        if Controls.brightness.Value == 0 then
            Controls.brightness.Value = 128
        end
        if Controls.last_command.String == "" then
            Controls.last_command.String = "Ready"
        end
        -- Always reset layout preset to default (don't persist layout selection)
        Controls.layout_preset.String = LayoutChoices[1]

        local colorChoices  = {"White","Red","Lime","Blue","Yellow","Magenta","Cyan",
                               "Orange","Purple","Green","Gold","Gray","Black"}
        local bgChoices     = {"Black","White","Red","Lime","Blue","Yellow","Magenta","Cyan",
                               "Orange","Purple","Green","Gold","Gray"}
        local fontChoices   = {"Arial","Verdana","Digital","Mono"}
        local sizeChoices   = {"auto","8","12","16","24","32"}
        local alignChoices  = {"Left","Center","Right"}
        local effectChoices = {"none","scroll","blink","fade"}
        local defaultColors = {"White","Lime","Red","Yellow"}

        for seg = 0, 3 do
            local s = "seg" .. (seg+1) .. "_"
            -- Always set Choices
            Controls[s.."text_color"].Choices = colorChoices
            Controls[s.."bg_color"].Choices   = bgChoices
            Controls[s.."font"].Choices       = fontChoices
            Controls[s.."size"].Choices       = sizeChoices
            Controls[s.."align"].Choices      = alignChoices
            Controls[s.."effect"].Choices     = effectChoices
            
            -- Only set defaults if empty (first run)
            if Controls[s.."text_color"].String == "" then
                Controls[s.."text_color"].String = defaultColors[seg+1]
            end
            if Controls[s.."bg_color"].String == "" then
                Controls[s.."bg_color"].String = "Black"
            end
            if Controls[s.."intensity"].Value == 0 then
                Controls[s.."intensity"].Value = 255
            end
            if Controls[s.."font"].String == "" then
                Controls[s.."font"].String = "Arial"
            end
            if Controls[s.."size"].String == "" then
                Controls[s.."size"].String = "auto"
            end
            if Controls[s.."align"].String == "" then
                Controls[s.."align"].String = "Center"
            end
            if Controls[s.."effect"].String == "" then
                Controls[s.."effect"].String = "none"
            end
        end

        -- Restore active segment indicators from current state
        activeLayoutSegments = activeLayoutSegments or {[0]=true}
        for seg = 0, 3 do
            Controls["seg"..(seg+1).."_active"].Boolean = (activeLayoutSegments[seg] == true)
        end

        ReopenSocket()
        print("=== Ready ===")
    end

    -- ── Layout handler ───────────────────────────────────────────────
    local function ApplyLayoutByKey(key)
        local p = LayoutPresets[key]
        if not p then
            print("✗ Unknown layout key: " .. tostring(key))
            Controls.last_command.String = "ERROR: unknown preset " .. tostring(key)
            return false
        end
        print("Applying layout: " .. p.name)

        -- Single UDP command — RPi resolves geometry for all presets 1-14
        SendCommand(buildJson({cmd="layout", preset=p.preset}))

        -- Update local segment tracking
        activeLayoutSegments = {}
        for _, seg in ipairs(p.activeSegments) do
            activeLayoutSegments[seg] = true
        end

        -- Update LED indicators
        for seg = 0, 3 do
            Controls["seg"..(seg+1).."_active"].Boolean = (activeLayoutSegments[seg] == true)
        end

        -- After settling, push text to active segments
        Timer.CallAfter(function()
            for _, seg in ipairs(p.activeSegments) do
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end
        end, 0.3)

        return true
    end

    -- Resolve ComboBox string or bare number string to preset key
    local function ResolvePreset(input)
        local num = tonumber(input)
        if num then return math.floor(num) end
        return LayoutNameToKey[input]
    end

    -- Reconnect button
    Controls.reconnect.EventHandler = function()
        print("=== Manual Reconnect Triggered ===")
        ReopenSocket()
        Controls.last_command.String = "Reconnected"
    end

    -- Apply button
    Controls.apply_layout.EventHandler = function()
        local key = ResolvePreset(Controls.layout_preset.String)
        if key then
            ApplyLayoutByKey(key)
        else
            print("✗ Invalid preset: " .. Controls.layout_preset.String)
            Controls.last_command.String = "ERROR: invalid preset"
        end
    end

    -- ComboBox selection immediately applies
    Controls.layout_preset.EventHandler = function(ctl)
        local key = ResolvePreset(ctl.String)
        if key then ApplyLayoutByKey(key) end
    end

    -- ── Per-segment handlers ────────────────────────────────────────
    for seg = 0, 3 do
        local s = "seg" .. (seg+1) .. "_"

        Controls[s.."send"].EventHandler = function()
            local _, cmd = BuildTextCommand(seg)
            if SendCommand(cmd) then
                Controls[s.."active"].Boolean = true
                activeLayoutSegments[seg] = true
            end
        end

        Controls[s.."clear"].EventHandler = function()
            if SendCommand(buildJson({cmd="clear", seg=seg})) then
                Controls[s.."active"].Boolean = false
                activeLayoutSegments[seg] = nil
            end
        end

        Controls[s.."invert"].EventHandler = function()
            local tc  = Controls[s.."text_color"]
            local bc  = Controls[s.."bg_color"]
            local tmp = tc.String
            tc.String = bc.String
            bc.String = tmp
            if activeLayoutSegments[seg] then
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end
        end

        local function AutoSend()
            if not activeLayoutSegments[seg] then return end
            local _, cmd = BuildTextCommand(seg)
            SendCommand(cmd)
        end

        Controls[s.."text"].EventHandler       = AutoSend
        Controls[s.."text_color"].EventHandler = AutoSend
        Controls[s.."bg_color"].EventHandler   = AutoSend
        Controls[s.."font"].EventHandler       = AutoSend
        Controls[s.."align"].EventHandler      = AutoSend
        Controls[s.."size"].EventHandler       = AutoSend
        Controls[s.."effect"].EventHandler     = AutoSend

        Controls[s.."intensity"].EventHandler = function()
            if not activeLayoutSegments[seg] then return end
            Debounce("intensity_"..seg, 0.5, function()
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end)
        end
    end

    -- ── Global controls ─────────────────────────────────────────────
    Controls.clear_all.EventHandler = function()
        if SendCommand(buildJson({cmd="clear_all"})) then
            for seg = 0, 3 do
                Controls["seg"..(seg+1).."_active"].Boolean = false
            end
            activeLayoutSegments = {}
        end
    end

    Controls.brightness.EventHandler = function(ctl)
        local value = math.floor(ctl.Value)
        Debounce("brightness", 0.5, function()
            SendCommand(buildJson({cmd="brightness", value=value}))
        end)
    end

    Controls.orientation.EventHandler = function(ctl)
        local orient = ctl.String
        if SendCommand(buildJson({cmd="orientation", value=orient})) then
            print("Orientation set to: " .. orient)
        end
    end

    -- ── Connection handlers ─────────────────────────────────────────
    Controls.ip_address.EventHandler = function(ctl)
        ip_addr = ctl.String
        print("IP changed to: " .. ip_addr)
        ReopenSocket()
    end

    Controls.udp_port.EventHandler = function(ctl)
        local v = ValidatePort(ctl.String)
        if v then
            udp_port = v
            print("Port changed to: " .. udp_port)
            ReopenSocket()
        else
            print("✗ Invalid port: " .. ctl.String)
            Controls.last_command.String = "ERROR: Invalid port"
        end
    end

    -- ── Cleanup ─────────────────────────────────────────────────────
    function Cleanup()
        for _, t in pairs(debounceTimers) do
            if t then pcall(function() t:Stop() end) end
        end
        if socket then pcall(function() socket:Close() end) end
    end

    Initialize()
end
