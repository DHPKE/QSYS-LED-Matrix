-- Q-SYS LED Matrix Controller Plugin - Complete Version
-- Version 3.7.0 - Clear pin names without grouping
-- Controls Olimex ESP32 Gateway 64x32 LED Matrix via UDP (JSON format)
--
-- v3.7.0 Changes:
--   - Removed PrettyName grouping approach (not working in Q-SYS Designer)
--   - Renamed all controls with clear segment prefixes: seg1_text, seg2_text, etc.
--   - All 48 segment pins now clearly labeled and individually accessible
--   - Alphabetical sorting in Control Pins window makes segments easy to find
--
-- v3.6.0 Changes:
--   - Fixed pin grouping in Q-SYS Designer Control Pins window
--   - Now uses PrettyName with tilde separator (e.g., "Segment 1~Text") for proper grouping
--   - Removed ControlGroup/Legend properties in favor of PrettyName standard
--
-- v3.5.0 Changes:
--   - Text input now auto-sends immediately when changed (no need for Display button)
--   - Inactive segments are never rendered (prevents editing inactive segments from
--     affecting the display when in Fullscreen or other layouts)
--   - All segment properties (text, colors, fonts, etc.) respect active/inactive state
--
-- FIRMWARE PROTOCOL (JSON over UDP):
--   {"cmd":"text","seg":0,"text":"Hello","color":"FFFFFF","bgcolor":"000000",
--    "font":"arial","size":"auto","align":"C","effect":"none","intensity":255}
--   {"cmd":"clear","seg":0}  |  {"cmd":"clear_all"}
--   {"cmd":"brightness","value":200}
--   {"cmd":"config","seg":0,"x":0,"y":0,"w":64,"h":32}

PluginInfo = {
    Name = "PKE~LED Matrix Display",
    Version = "3.7.0",
    Id = "dhpke.olimex.led.matrix.3.7.0",
    Description = "Complete JSON UDP control for Olimex ESP32 Gateway 64x32 LED Matrix - Clearly labeled segment pins",
    ShowDebug = true,
    Author = "DHPKE"
}

-- Define plugin properties
function GetProperties()
    return {
        {
            Name = "IP Address",
            Type = "string",
            Value = "192.168.1.100"
        },
        {
            Name = "UDP Port",
            Type = "integer",
            Min = 1,
            Max = 65535,
            Value = 21324
        }
    }
end

-- CSS color name to hex mapping (inside Runtime scope – moved below)

-- Define controls
function GetControls(props)
    local controls = {}
    
    -- Connection controls
    table.insert(controls, {
        Name = "ip_address",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    table.insert(controls, {
        Name = "udp_port",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    table.insert(controls, {
        Name = "connection_status",
        ControlType = "Indicator",
        IndicatorType = "Status",
        Count = 1,
        UserPin = true,
        PinStyle = "Output"
    })
    
    table.insert(controls, {
        Name = "last_command",
        ControlType = "Text",
        Count = 1,
        UserPin = false,
        PinStyle = "Output"
    })
    
    -- Layout controls
    table.insert(controls, {
        Name = "layout",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Both"
    })
    
    table.insert(controls, {
        Name = "apply_layout",
        ControlType = "Button",
        ButtonType = "Trigger",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    -- Segment controls (4 segments)
    for seg = 0, 3 do
        local segNum = seg + 1  -- Display as Segment 1-4
        
        -- Text input
        table.insert(controls, {
            Name = string.format("seg%d_text", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Text color selector
        table.insert(controls, {
            Name = string.format("seg%d_text_color", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Background color selector
        table.insert(controls, {
            Name = string.format("seg%d_bg_color", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Alignment selector
        table.insert(controls, {
            Name = string.format("seg%d_align", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })

        -- Effect selector
        table.insert(controls, {
            Name = string.format("seg%d_effect", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Font selector
        table.insert(controls, {
            Name = string.format("seg%d_font", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })

        -- Font size selector
        table.insert(controls, {
            Name = string.format("seg%d_size", segNum),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Intensity control
        table.insert(controls, {
            Name = string.format("seg%d_intensity", segNum),
            ControlType = "Knob",
            ControlUnit = "Integer",
            Min = 0,
            Max = 255,
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })

        -- Send button
        table.insert(controls, {
            Name = string.format("seg%d_send", segNum),
            ControlType = "Button",
            ButtonType = "Trigger",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Clear button
        table.insert(controls, {
            Name = string.format("seg%d_clear", segNum),
            ControlType = "Button",
            ButtonType = "Trigger",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Invert button (swaps text and background colors)
        table.insert(controls, {
            Name = string.format("seg%d_invert", segNum),
            ControlType = "Button",
            ButtonType = "Trigger",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Active indicator
        table.insert(controls, {
            Name = string.format("seg%d_active", segNum),
            ControlType = "Indicator",
            IndicatorType = "LED",
            Count = 1,
            UserPin = true,
            PinStyle = "Output"
        })
    end
    
    -- Global controls
    table.insert(controls, {
        Name = "brightness",
        ControlType = "Knob",
        ControlUnit = "Integer",
        Min = 0,
        Max = 255,
        Count = 1,
        UserPin = true,
        PinStyle = "Both"
    })
    
    table.insert(controls, {
        Name = "clear_all",
        ControlType = "Button",
        ButtonType = "Trigger",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    return controls
end

-- Define UI layout
function GetControlLayout(props)
    local layout   = {}
    local graphics = {}
    local W  = 900   -- plugin width
    local CH = 24    -- standard control height
    local BH = 28    -- button height

    local C_GRP   = {62,  62,  62 }
    local C_LBL   = {205, 205, 205}
    local C_BTN_G = {0,   148, 55 }
    local C_BTN_R = {165, 38,  38 }
    local C_BTN_B = {45,  105, 195}

    local function GBox(x, y, w, h, title)
        table.insert(graphics, {Type="GroupBox", Text=title or "", Fill=C_GRP,
            StrokeWidth=1, CornerRadius=4, Position={x,y}, Size={w,h}})
    end
    local function Lbl(text, x, y, w)
        table.insert(graphics, {Type="Text", Text=text, Font="Roboto", FontSize=9,
            HTextAlign="Left", Color=C_LBL, Position={x,y}, Size={w,12}})
    end

    -- ── Title ──────────────────────────────────────────────────────
    table.insert(graphics, {Type="GroupBox", Text="", Fill={38,38,38},
        StrokeWidth=0, CornerRadius=5, Position={0,0}, Size={W,36}})
    table.insert(graphics, {Type="Text", Text="LED Matrix Complete Controller  v3.5.0",
        Font="Roboto", FontSize=14, FontStyle="Bold", HTextAlign="Center",
        Color={255,255,255}, Position={0,9}, Size={W,20}})

    -- ── Connection ─────────────────────────────────────────────────
    local y = 42
    GBox(0, y, W, 54, "Connection")
    Lbl("IP Address",   6, y+5, 124)
    Lbl("Port",       138, y+5,  62)
    Lbl("Status",     208, y+5,  62)
    Lbl("Last Command", 278, y+5, W-284)
    layout["ip_address"]        = {PrettyName="IP Address",   Style="Text",
        Position={6,   y+18}, Size={124, CH}}
    layout["udp_port"]          = {PrettyName="Port",         Style="Text",
        Position={138, y+18}, Size={62,  CH}}
    layout["connection_status"] = {PrettyName="Status",       Style="Indicator",
        Position={208, y+18}, Size={62,  CH}}
    layout["last_command"]      = {PrettyName="Last Command", Style="Text",
        Position={278, y+18}, Size={W-284, CH}}

    -- ── Display Layout ─────────────────────────────────────────────
    y = y + 60
    GBox(0, y, W, 50, "Display Layout")
    Lbl("Layout Preset", 6, y+5, 190)
    layout["layout"] = {PrettyName="Layout Preset", Style="ComboBox",
        IsReadOnly=false,
        Position={6, y+18}, Size={190, CH}}
    layout["apply_layout"] = {PrettyName="Apply", Style="Button",
        ButtonStyle="Trigger", Legend="Apply Layout", Color=C_BTN_B,
        Position={204, y+18}, Size={130, CH}}

    -- ── Segments ───────────────────────────────────────────────────
    y = y + 56
    -- Each segment box has 3 rows:
    --   Row1 (y+16):  LED | text input | Display | Clear
    --   Row2 (y+52):  Text Color | BG Color | Font | Size | Align | Effect
    --   Row3 (y+88):  Intensity fader
    local SEG_H = 122

    for seg = 0, 3 do
        local s  = tostring(seg)
        local sy = y + seg * (SEG_H + 4)

        GBox(0, sy, W, SEG_H, "Segment " .. (seg+1))

        -- Row 1
        local r1 = sy + 16
        layout["active_"..s] = {PrettyName="Active", Style="Led",
            Position={6, r1+5}, Size={14, 14}}
        Lbl("Text", 26, r1-12, W-230)
        layout["text_"..s]  = {PrettyName="Text", Style="Text",
            Position={26, r1}, Size={W-232, CH}}
        layout["send_"..s]  = {PrettyName="Display", Style="Button",
            ButtonStyle="Trigger", Legend="Display", Color=C_BTN_G,
            Position={W-300, r1}, Size={95, BH}}
        layout["invert_"..s] = {PrettyName="Invert", Style="Button",
            ButtonStyle="Trigger", Legend="Invert", Color=C_BTN_B,
            Position={W-199,  r1}, Size={95, BH}}
        layout["clear_"..s] = {PrettyName="Clear", Style="Button",
            ButtonStyle="Trigger", Legend="Clear", Color=C_BTN_R,
            Position={W-98,  r1}, Size={92, BH}}

        -- Row 2: 6 ComboBoxes
        local r2 = sy + 52
        -- {label, control_name_prefix, width}
        local cols = {
            {"Text Color", "text_color_", 114},
            {"BG Color",   "bg_color_",   114},
            {"Font",       "font_",        84},
            {"Size",       "size_",        68},
            {"Align",      "align_",       78},
            {"Effect",     "effect_",      96},
        }
        local cx = 6
        for _, col in ipairs(cols) do
            Lbl(col[1], cx, r2-13, col[3])
            layout[col[2]..s] = {PrettyName=col[1], Style="ComboBox",
                IsReadOnly=false,
                Position={cx, r2}, Size={col[3], CH}}
            cx = cx + col[3] + 6
        end

        -- Row 3: Intensity fader
        local r3 = sy + 88
        Lbl("Intensity  (0 = off, 255 = full)", 6, r3-13, 260)
        layout["intensity_"..s] = {PrettyName="Intensity", Style="Fader",
            Position={6, r3}, Size={W-14, 22}}
    end

    -- ── Global Controls ────────────────────────────────────────────
    y = y + 4 * (SEG_H + 4) + 4
    GBox(0, y, W, 64, "Global Controls")
    Lbl("Global Brightness", 6, y+5, 220)
    layout["brightness"] = {PrettyName="Global Brightness", Style="Fader",
        Position={6, y+18}, Size={340, 36}}
    layout["clear_all"] = {PrettyName="Clear All", Style="Button",
        ButtonStyle="Trigger", Legend="Clear All Segments", Color=C_BTN_R,
        Position={354, y+18}, Size={200, 36}}

    return layout, graphics
end

-- Runtime code
if Controls then
    -- UDP socket
    local socket   = nil
    local ip_addr  = Properties["IP Address"].Value
    local udp_port = Properties["UDP Port"].Value

    -- Track which segments are part of the current layout (0-indexed keys)
    local activeLayoutSegments = {}

    -- Debounce timer table (keyed by arbitrary string label)
    local debounceTimers = {}

    -- ── Lookup tables ──────────────────────────────────────────────
    local ColorNames = {
        ["White"]   = "FFFFFF", ["Red"]     = "FF0000", ["Lime"]    = "00FF00",
        ["Blue"]    = "0000FF", ["Yellow"]  = "FFFF00", ["Magenta"] = "FF00FF",
        ["Cyan"]    = "00FFFF", ["Orange"]  = "FFA500", ["Purple"]  = "800080",
        ["Green"]   = "008000", ["Pink"]    = "FFC0CB", ["Gold"]    = "FFD700",
        ["Silver"]  = "C0C0C0", ["Gray"]    = "808080", ["Black"]   = "000000"
    }

    local FontMap = {
        ["Arial"]   = "arial",
        ["Verdana"] = "verdana",
        ["Digital"] = "digital12",
        ["Mono"]    = "mono9"
    }

    local AlignMap = {
        ["Left"]   = "L",
        ["Center"] = "C",
        ["Right"]  = "R"
    }

    -- ── Layout configurations ──────────────────────────────────────
    local LayoutConfigs = {
        ["Fullscreen"] = {
            activeSegments = {0},
            configs = {
                {seg=0, x=0,  y=0,  w=64, h=32}
            },
            clears = {1, 2, 3}
        },
        ["Split Vertical"] = {
            activeSegments = {0, 1},
            configs = {
                {seg=0, x=0,  y=0, w=32, h=32},
                {seg=1, x=32, y=0, w=32, h=32}
            },
            clears = {2, 3}
        },
        ["Split Horizontal"] = {
            activeSegments = {0, 1},
            configs = {
                {seg=0, x=0, y=0,  w=64, h=16},
                {seg=1, x=0, y=16, w=64, h=16}
            },
            clears = {2, 3}
        },
        ["Quad"] = {
            activeSegments = {0, 1, 2, 3},
            configs = {
                {seg=0, x=0,  y=0,  w=32, h=16},
                {seg=1, x=32, y=0,  w=32, h=16},
                {seg=2, x=0,  y=16, w=32, h=16},
                {seg=3, x=32, y=16, w=32, h=16}
            },
            clears = {}
        }
    }

    -- ── Helpers ────────────────────────────────────────────────────

    local function Debounce(key, delay, fn)
        if debounceTimers[key] then debounceTimers[key]:Stop() end
        if not debounceTimers[key] then debounceTimers[key] = Timer.New() end
        local t = debounceTimers[key]
        t.EventHandler = function() t:Stop(); fn() end
        t:Start(delay)
    end

    local function ReopenSocket()
        if socket then pcall(function() socket:Close() end) end
        local ok, err = pcall(function()
            socket = UdpSocket.New()
            socket:Open()
        end)
        if ok then
            Controls.connection_status.Value = 0
            print("✓ UDP socket ready → " .. ip_addr .. ":" .. udp_port)
        else
            Controls.connection_status.Value = 2
            print("✗ Socket error: " .. tostring(err))
        end
    end

    local function ValidatePort(port)
        local num = tonumber(port)
        if num and num >= 1 and num <= 65535 then return num end
        return nil
    end

    -- ── JSON helpers ───────────────────────────────────────────────
    -- Minimal JSON serialiser (no external library needed in Lua)
    local function jsonStr(v)
        if v == nil then return "null" end
        if type(v) == "number" then return tostring(math.floor(v)) end
        if type(v) == "boolean" then return v and "true" or "false" end
        -- string: escape backslash and double-quote
        v = tostring(v)
        v = v:gsub('\\', '\\\\'):gsub('"', '\\"')
        return '"' .. v .. '"'
    end

    local function buildJson(t)
        local parts = {}
        for k, v in pairs(t) do
            table.insert(parts, jsonStr(k) .. ":" .. jsonStr(v))
        end
        return "{" .. table.concat(parts, ",") .. "}"
    end

    -- Send a UDP datagram to the configured target.
    local function SendCommand(json)
        if not socket then
            print("✗ ERROR: Socket not initialized")
            Controls.connection_status.Value = 2
            Controls.last_command.String = "ERROR: No socket"
            return false
        end
        local ok, err = pcall(function()
            socket:Send(ip_addr, udp_port, json .. "\n")
        end)
        if ok then
            print("→ " .. json)
            Controls.last_command.String = json
            Controls.connection_status.Value = 0
            return true
        else
            print("✗ Send error: " .. tostring(err))
            Controls.last_command.String = "ERROR: " .. tostring(err)
            Controls.connection_status.Value = 2
            return false
        end
    end

    -- Build a JSON "text" command for a segment from current control values.
    local function BuildTextCommand(seg)
        local segName = "seg"..(seg+1).."_"
        local text    = Controls[segName.."text"].String
        local color   = ColorNames[Controls[segName.."text_color"].String] or "FFFFFF"
        local bgcolor = ColorNames[Controls[segName.."bg_color"].String]   or "000000"
        local font    = FontMap[Controls[segName.."font"].String]          or "arial"
        local size    = Controls[segName.."size"].String                   or "auto"
        local align   = AlignMap[Controls[segName.."align"].String]        or "C"
        local effect  = Controls[segName.."effect"].String                 or "none"
        local intens  = math.floor(Controls[segName.."intensity"].Value)

        local json = buildJson({
            cmd       = "text",
            seg       = seg,
            text      = text,
            color     = color,
            bgcolor   = bgcolor,
            font      = font,
            size      = size,
            align     = align,
            effect    = effect,
            intensity = intens
        })
        return text, json
    end

    -- ── Initialize ─────────────────────────────────────────────────
    local function Initialize()
        print("===========================================")
        print("LED Matrix Complete v3.7.0 Initializing")
        print("===========================================")

        Controls.ip_address.String   = ip_addr
        Controls.udp_port.String     = tostring(udp_port)
        Controls.brightness.Value    = 128
        Controls.last_command.String = "Ready"

        -- Choices must be set at runtime for Q-SYS ComboBox to work
        Controls.layout.Choices = {"Fullscreen", "Split Vertical", "Split Horizontal", "Quad"}
        Controls.layout.String  = "Fullscreen"

        -- Seed active segments for the default layout (Fullscreen = seg 0 only)
        activeLayoutSegments = {[0] = true}

        local colorChoices  = {"White","Red","Lime","Blue","Yellow","Magenta","Cyan",
                               "Orange","Purple","Green","Pink","Gold","Silver","Gray","Black"}
        local bgChoices     = {"Black","White","Red","Lime","Blue","Yellow","Magenta","Cyan",
                               "Orange","Purple","Green","Pink","Gold","Silver","Gray"}
        local fontChoices   = {"Arial","Verdana","Digital","Mono"}
        local sizeChoices   = {"auto","8","12","16","24","32"}
        local alignChoices  = {"Left","Center","Right"}
        local effectChoices = {"none","scroll","blink","fade"}

        local defaultColors = {"White","Lime","Red","Yellow"}
        for seg = 0, 3 do
            local segName = "seg"..(seg+1).."_"
            Controls[segName.."text_color"].Choices = colorChoices
            Controls[segName.."bg_color"].Choices   = bgChoices
            Controls[segName.."font"].Choices       = fontChoices
            Controls[segName.."size"].Choices       = sizeChoices
            Controls[segName.."align"].Choices      = alignChoices
            Controls[segName.."effect"].Choices     = effectChoices

            Controls[segName.."text"].String        = ""
            Controls[segName.."text_color"].String  = defaultColors[seg + 1]
            Controls[segName.."bg_color"].String    = "Black"
            Controls[segName.."intensity"].Value    = 255
            Controls[segName.."font"].String        = "Arial"
            Controls[segName.."size"].String        = "auto"
            Controls[segName.."align"].String       = "Center"
            Controls[segName.."effect"].String      = "none"
            Controls[segName.."active"].Boolean     = false
        end

        ReopenSocket()
        print("===========================================")
    end

    -- ── Layout handler ─────────────────────────────────────────────
    Controls.apply_layout.EventHandler = function()
        local layoutName = Controls.layout.String
        local config     = LayoutConfigs[layoutName]
        if not config then
            print("✗ Unknown layout: " .. layoutName)
            return
        end
        print("Applying layout: " .. layoutName)

        -- Update the active-segments set FIRST so AutoSend guards are correct
        activeLayoutSegments = {}
        for _, s in ipairs(config.activeSegments) do activeLayoutSegments[s] = true end

        -- Send config geometry for active segments
        for _, cfg in ipairs(config.configs) do
            SendCommand(buildJson({cmd="config", seg=cfg.seg,
                x=cfg.x, y=cfg.y, w=cfg.w, h=cfg.h}))
        end

        -- Clear (and deactivate on firmware) the segments not in this layout
        for _, seg in ipairs(config.clears) do
            SendCommand(buildJson({cmd="clear", seg=seg}))
        end

        -- Update LED indicators
        for seg = 0, 3 do
            Controls["seg"..(seg+1).."_active"].Boolean = activeLayoutSegments[seg] == true
        end

        -- After a short settling delay, push text content to active segments
        Timer.CallAfter(function()
            for _, seg in ipairs(config.activeSegments) do
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end
        end, 0.3)
    end

    -- ── Per-segment send / clear handlers ──────────────────────────
    for seg = 0, 3 do
        local segName = "seg"..(seg+1).."_"

        -- Manual "Display" button — can activate a segment even if not in current layout
        Controls[segName.."send"].EventHandler = function()
            local text, cmd = BuildTextCommand(seg)
            if SendCommand(cmd) then
                Controls[segName.."active"].Boolean = true
                activeLayoutSegments[seg] = true
            end
        end

        -- Manual "Clear" button — deactivates segment
        Controls[segName.."clear"].EventHandler = function()
            if SendCommand(buildJson({cmd="clear", seg=seg})) then
                Controls[segName.."active"].Boolean = false
                activeLayoutSegments[seg] = nil
            end
        end
        
        -- "Invert" button — swaps text color and background color
        Controls[segName.."invert"].EventHandler = function()
            local textColorCtrl = Controls[segName.."text_color"]
            local bgColorCtrl = Controls[segName.."bg_color"]
            
            -- Swap the values
            local tempColor = textColorCtrl.String
            textColorCtrl.String = bgColorCtrl.String
            bgColorCtrl.String = tempColor
            
            -- Auto-send if segment is active
            if activeLayoutSegments[seg] then
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end
        end

        -- Auto-send when any display property changes, but ONLY if this
        -- segment is part of the currently applied layout (active).
        -- This prevents editing inactive segments from affecting the display.
        local function AutoSend()
            if not activeLayoutSegments[seg] then return end
            local _, cmd = BuildTextCommand(seg)
            SendCommand(cmd)
        end
        
        -- Text input auto-sends immediately when changed (only if segment is active)
        Controls[segName.."text"].EventHandler = AutoSend
        
        Controls[segName.."text_color"].EventHandler = AutoSend
        Controls[segName.."bg_color"].EventHandler   = AutoSend
        Controls[segName.."font"].EventHandler       = AutoSend
        Controls[segName.."align"].EventHandler      = AutoSend
        Controls[segName.."size"].EventHandler       = AutoSend
        Controls[segName.."effect"].EventHandler     = AutoSend

        Controls[segName.."intensity"].EventHandler = function(ctl)
            if not activeLayoutSegments[seg] then return end
            Debounce("intensity_"..seg, 0.5, function()
                local _, cmd = BuildTextCommand(seg)
                SendCommand(cmd)
            end)
        end
    end

    -- ── Global controls ─────────────────────────────────────────────
    Controls.clear_all.EventHandler = function()
        if SendCommand(buildJson({cmd="clear_all"})) then
            for seg = 0, 3 do
                Controls["seg"..(seg+1).."_active"].Boolean = false
            end
        end
    end

    Controls.brightness.EventHandler = function(ctl)
        local value = math.floor(ctl.Value)
        Debounce("brightness", 0.5, function()
            SendCommand(buildJson({cmd="brightness", value=value}))
        end)
    end

    -- ── Connection change handlers ──────────────────────────────────
    Controls.ip_address.EventHandler = function(ctl)
        ip_addr = ctl.String
        print("IP address changed to: " .. ip_addr)
        ReopenSocket()
    end

    Controls.udp_port.EventHandler = function(ctl)
        local validated = ValidatePort(ctl.String)
        if validated then
            udp_port = validated
            print("UDP port changed to: " .. udp_port)
            ReopenSocket()
        else
            print("✗ Invalid port: " .. ctl.String)
            Controls.last_command.String = "ERROR: Invalid port"
        end
    end

    -- ── Cleanup ─────────────────────────────────────────────────────
    function Cleanup()
        print("Cleaning up LED Matrix Controller...")
        for _, t in pairs(debounceTimers) do
            if t then pcall(function() t:Stop() end) end
        end
        if socket then pcall(function() socket:Close() end) end
    end

    Initialize()
end
