-- Q-SYS LED Matrix Controller Plugin - Complete Version
-- Version 3.3.0 - All firmware features: size, effect, auto-send on change
-- Controls Olimex ESP32 Gateway 64x32 LED Matrix via UDP
--
-- FIRMWARE PROTOCOL: TEXT|seg|content|color|font|size|align|effect|bgcolor|intensity
--                    CLEAR|seg  |  CLEAR_ALL  |  BRIGHTNESS|val
--                    CONFIG|segment|seg|x/y/width/height|val

PluginInfo = {
    Name = "Olimex~LED Matrix Complete",
    Version = "3.3.0",
    Id = "dhpke.olimex.led.matrix.3.3.0",
    Description = "Complete UDP control for Olimex ESP32 Gateway 64x32 LED Matrix with all features",
    ShowDebug = true,
    Author = "DHPKE"
}

-- Define plugin properties
function GetProperties()
    return {
        {
            Name = "IP Address",
            Type = "string",
            Value = "192.168.1.100"
        },
        {
            Name = "UDP Port",
            Type = "integer",
            Min = 1,
            Max = 65535,
            Value = 21324
        }
    }
end

-- CSS color name to hex mapping
ColorNames = {
    ["White"] = "FFFFFF",
    ["Red"] = "FF0000",
    ["Lime"] = "00FF00",
    ["Blue"] = "0000FF",
    ["Yellow"] = "FFFF00",
    ["Magenta"] = "FF00FF",
    ["Cyan"] = "00FFFF",
    ["Orange"] = "FFA500",
    ["Purple"] = "800080",
    ["Green"] = "008000",
    ["Pink"] = "FFC0CB",
    ["Gold"] = "FFD700",
    ["Silver"] = "C0C0C0",
    ["Gray"] = "808080",
    ["Black"] = "000000"
}

-- Define controls
function GetControls(props)
    local controls = {}
    
    -- Connection controls
    table.insert(controls, {
        Name = "ip_address",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    table.insert(controls, {
        Name = "udp_port",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    table.insert(controls, {
        Name = "connection_status",
        ControlType = "Indicator",
        IndicatorType = "Status",
        Count = 1,
        UserPin = true,
        PinStyle = "Output"
    })
    
    table.insert(controls, {
        Name = "last_command",
        ControlType = "Text",
        Count = 1,
        UserPin = false,
        PinStyle = "Output"
    })
    
    -- Layout controls
    table.insert(controls, {
        Name = "layout",
        ControlType = "Text",
        Count = 1,
        UserPin = true,
        PinStyle = "Both"
    })
    
    table.insert(controls, {
        Name = "apply_layout",
        ControlType = "Button",
        ButtonType = "Trigger",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    -- Segment controls (4 segments)
    for seg = 0, 3 do
        -- Active indicator
        table.insert(controls, {
            Name = string.format("active_%d", seg),
            ControlType = "Indicator",
            IndicatorType = "LED",
            Count = 1,
            UserPin = true,
            PinStyle = "Output"
        })
        
        -- Text input
        table.insert(controls, {
            Name = string.format("text_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Text color selector
        table.insert(controls, {
            Name = string.format("text_color_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Background color selector
        table.insert(controls, {
            Name = string.format("bg_color_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Intensity control
        table.insert(controls, {
            Name = string.format("intensity_%d", seg),
            ControlType = "Knob",
            ControlUnit = "Integer",
            Min = 0,
            Max = 255,
            Count = 1,
            UserPin = true,
            PinStyle = "Both"
        })
        
        -- Font selector
        table.insert(controls, {
            Name = string.format("font_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Alignment selector
        table.insert(controls, {
            Name = string.format("align_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })

        -- Font size selector
        table.insert(controls, {
            Name = string.format("size_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })

        -- Effect selector
        table.insert(controls, {
            Name = string.format("effect_%d", seg),
            ControlType = "Text",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })

        -- Send button
        table.insert(controls, {
            Name = string.format("send_%d", seg),
            ControlType = "Button",
            ButtonType = "Trigger",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
        
        -- Clear button
        table.insert(controls, {
            Name = string.format("clear_%d", seg),
            ControlType = "Button",
            ButtonType = "Trigger",
            Count = 1,
            UserPin = true,
            PinStyle = "Input"
        })
    end
    
    -- Global controls
    table.insert(controls, {
        Name = "brightness",
        ControlType = "Knob",
        ControlUnit = "Integer",
        Min = 0,
        Max = 255,
        Count = 1,
        UserPin = true,
        PinStyle = "Both"
    })
    
    table.insert(controls, {
        Name = "clear_all",
        ControlType = "Button",
        ButtonType = "Trigger",
        Count = 1,
        UserPin = true,
        PinStyle = "Input"
    })
    
    return controls
end

-- Define UI layout
function GetControlLayout(props)
    local layout   = {}
    local graphics = {}
    local W  = 900   -- plugin width
    local CH = 24    -- standard control height
    local BH = 28    -- button height

    local C_GRP   = {62,  62,  62 }
    local C_LBL   = {205, 205, 205}
    local C_BTN_G = {0,   148, 55 }
    local C_BTN_R = {165, 38,  38 }
    local C_BTN_B = {45,  105, 195}

    local function GBox(x, y, w, h, title)
        table.insert(graphics, {Type="GroupBox", Text=title or "", Fill=C_GRP,
            StrokeWidth=1, CornerRadius=4, Position={x,y}, Size={w,h}})
    end
    local function Lbl(text, x, y, w)
        table.insert(graphics, {Type="Text", Text=text, Font="Roboto", FontSize=9,
            HTextAlign="Left", Color=C_LBL, Position={x,y}, Size={w,12}})
    end

    -- ── Title ──────────────────────────────────────────────────────
    table.insert(graphics, {Type="GroupBox", Text="", Fill={38,38,38},
        StrokeWidth=0, CornerRadius=5, Position={0,0}, Size={W,36}})
    table.insert(graphics, {Type="Text", Text="LED Matrix Complete Controller  v3.3",
        Font="Roboto", FontSize=14, FontStyle="Bold", HTextAlign="Center",
        Color={255,255,255}, Position={0,9}, Size={W,20}})

    -- ── Connection ─────────────────────────────────────────────────
    local y = 42
    GBox(0, y, W, 54, "Connection")
    Lbl("IP Address",   6, y+5, 124)
    Lbl("Port",       138, y+5,  62)
    Lbl("Status",     208, y+5,  62)
    Lbl("Last Command", 278, y+5, W-284)
    layout["ip_address"]        = {PrettyName="IP Address",   Style="Text",
        Position={6,   y+18}, Size={124, CH}}
    layout["udp_port"]          = {PrettyName="Port",         Style="Text",
        Position={138, y+18}, Size={62,  CH}}
    layout["connection_status"] = {PrettyName="Status",       Style="Indicator",
        Position={208, y+18}, Size={62,  CH}}
    layout["last_command"]      = {PrettyName="Last Command", Style="Text",
        Position={278, y+18}, Size={W-284, CH}}

    -- ── Display Layout ─────────────────────────────────────────────
    y = y + 60
    GBox(0, y, W, 50, "Display Layout")
    Lbl("Layout Preset", 6, y+5, 190)
    layout["layout"] = {PrettyName="Layout Preset", Style="ComboBox",
        IsReadOnly=false,
        Position={6, y+18}, Size={190, CH}}
    layout["apply_layout"] = {PrettyName="Apply", Style="Button",
        ButtonStyle="Trigger", Legend="Apply Layout", Color=C_BTN_B,
        Position={204, y+18}, Size={130, CH}}

    -- ── Segments ───────────────────────────────────────────────────
    y = y + 56
    -- Each segment box has 3 rows:
    --   Row1 (y+16):  LED | text input | Display | Clear
    --   Row2 (y+52):  Text Color | BG Color | Font | Size | Align | Effect
    --   Row3 (y+88):  Intensity fader
    local SEG_H = 122

    for seg = 0, 3 do
        local s  = tostring(seg)
        local sy = y + seg * (SEG_H + 4)

        GBox(0, sy, W, SEG_H, "Segment " .. (seg+1))

        -- Row 1
        local r1 = sy + 16
        layout["active_"..s] = {PrettyName="Active", Style="Led",
            Position={6, r1+5}, Size={14, 14}}
        Lbl("Text", 26, r1-12, W-230)
        layout["text_"..s]  = {PrettyName="Text", Style="Text",
            Position={26, r1}, Size={W-232, CH}}
        layout["send_"..s]  = {PrettyName="Display", Style="Button",
            ButtonStyle="Trigger", Legend="Display", Color=C_BTN_G,
            Position={W-200, r1}, Size={95, BH}}
        layout["clear_"..s] = {PrettyName="Clear", Style="Button",
            ButtonStyle="Trigger", Legend="Clear", Color=C_BTN_R,
            Position={W-99,  r1}, Size={93, BH}}

        -- Row 2: 6 ComboBoxes
        local r2 = sy + 52
        -- {label, control_name_prefix, width}
        local cols = {
            {"Text Color", "text_color_", 114},
            {"BG Color",   "bg_color_",   114},
            {"Font",       "font_",        84},
            {"Size",       "size_",        68},
            {"Align",      "align_",       78},
            {"Effect",     "effect_",      96},
        }
        local cx = 6
        for _, col in ipairs(cols) do
            Lbl(col[1], cx, r2-13, col[3])
            layout[col[2]..s] = {PrettyName=col[1], Style="ComboBox",
                IsReadOnly=false,
                Position={cx, r2}, Size={col[3], CH}}
            cx = cx + col[3] + 6
        end

        -- Row 3: Intensity fader
        local r3 = sy + 88
        Lbl("Intensity  (0 = off, 255 = full)", 6, r3-13, 260)
        layout["intensity_"..s] = {PrettyName="Intensity", Style="Fader",
            Position={6, r3}, Size={W-14, 22}}
    end

    -- ── Global Controls ────────────────────────────────────────────
    y = y + 4 * (SEG_H + 4) + 4
    GBox(0, y, W, 64, "Global Controls")
    Lbl("Global Brightness", 6, y+5, 220)
    layout["brightness"] = {PrettyName="Global Brightness", Style="Fader",
        Position={6, y+18}, Size={340, 36}}
    layout["clear_all"] = {PrettyName="Clear All", Style="Button",
        ButtonStyle="Trigger", Legend="Clear All Segments", Color=C_BTN_R,
        Position={354, y+18}, Size={200, 36}}

    return layout, graphics
end

-- Runtime code
if Controls then
    -- UDP socket
    local socket = nil
    local ip_addr = Properties["IP Address"].Value
    local udp_port = Properties["UDP Port"].Value

    -- Debounce timer table (keyed by arbitrary string label)
    local debounceTimers = {}

    -- Font name mapping
    local FontMap = {
        ["Arial"]   = "arial",
        ["Verdana"] = "verdana",
        ["Digital"] = "digital12",
        ["Mono"]    = "mono9"
    }

    -- Alignment mapping
    local AlignMap = {
        ["Left"]   = "L",
        ["Center"] = "C",
        ["Right"]  = "R"
    }

    -- Layout configurations
    local LayoutConfigs = {
        ["Fullscreen"] = {
            activeSegments = {0},
            configs = {
                {seg = 0, x = 0, y = 0, width = 64, height = 32}
            },
            clears = {1, 2, 3}
        },
        ["Split Vertical"] = {
            activeSegments = {0, 1},
            configs = {
                {seg = 0, x = 0,  y = 0, width = 32, height = 32},
                {seg = 1, x = 32, y = 0, width = 32, height = 32}
            },
            clears = {2, 3}
        },
        ["Split Horizontal"] = {
            activeSegments = {0, 1},
            configs = {
                {seg = 0, x = 0, y = 0,  width = 64, height = 16},
                {seg = 1, x = 0, y = 16, width = 64, height = 16}
            },
            clears = {2, 3}
        },
        ["Quad"] = {
            activeSegments = {0, 1, 2, 3},
            configs = {
                {seg = 0, x = 0,  y = 0,  width = 32, height = 16},
                {seg = 1, x = 32, y = 0,  width = 32, height = 16},
                {seg = 2, x = 0,  y = 16, width = 32, height = 16},
                {seg = 3, x = 32, y = 16, width = 32, height = 16}
            },
            clears = {}
        }
    }

    -- ---------------------------------------------------------------
    -- Helpers
    -- ---------------------------------------------------------------

    -- Generic debounce: stop any pending timer with the given key,
    -- then fire fn once after `delay` seconds.
    -- Q-SYS Timer.New() repeats; we stop it inside the handler to make it one-shot.
    local function Debounce(key, delay, fn)
        if debounceTimers[key] then
            debounceTimers[key]:Stop()
        end
        if not debounceTimers[key] then
            debounceTimers[key] = Timer.New()
        end
        local t = debounceTimers[key]
        t.EventHandler = function()
            t:Stop()
            fn()
        end
        t:Start(delay)
    end

    -- (Re)open the UDP socket. UdpSocket is connectionless; IP/port
    -- are supplied per-Send, not at open time.
    local function ReopenSocket()
        if socket then pcall(function() socket:Close() end) end
        local ok, err = pcall(function()
            socket = UdpSocket.New()
            socket:Open()
        end)
        if ok then
            Controls.connection_status.Value = 0
            print("✓ UDP socket ready, targeting " .. ip_addr .. ":" .. udp_port)
        else
            Controls.connection_status.Value = 2
            print("✗ Socket error: " .. tostring(err))
        end
    end

    -- Validate port string → number, or nil.
    local function ValidatePort(port)
        local num = tonumber(port)
        if num and num >= 1 and num <= 65535 then return num end
        return nil
    end

    -- Send a UDP datagram to the configured target.
    local function SendCommand(command)
        if not socket then
            print("✗ ERROR: Socket not initialized")
            Controls.connection_status.Value = 2
            Controls.last_command.String = "ERROR: No socket"
            return false
        end
        local ok, err = pcall(function()
            socket:Send(ip_addr, udp_port, command .. "\n")
        end)
        if ok then
            print("→ " .. command)
            Controls.last_command.String = command
            Controls.connection_status.Value = 0
            return true
        else
            print("✗ Send error: " .. tostring(err))
            Controls.last_command.String = "ERROR: " .. tostring(err)
            Controls.connection_status.Value = 2
            return false
        end
    end

    -- Build the TEXT command string for a segment using its current control values.
    -- Protocol: TEXT|seg|content|color|font|size|align|effect|bgcolor|intensity
    local function BuildTextCommand(seg)
        local text      = Controls[string.format("text_%d",       seg)].String
        local textColor = ColorNames[Controls[string.format("text_color_%d", seg)].String] or "FFFFFF"
        local bgColor   = ColorNames[Controls[string.format("bg_color_%d",   seg)].String] or "000000"
        local intensity = math.floor(Controls[string.format("intensity_%d",  seg)].Value)
        local font      = FontMap[Controls[string.format("font_%d",  seg)].String] or "arial"
        local size      = Controls[string.format("size_%d",   seg)].String or "auto"
        local align     = AlignMap[Controls[string.format("align_%d", seg)].String] or "C"
        local effect    = Controls[string.format("effect_%d", seg)].String or "none"
        return text, string.format("TEXT|%d|%s|%s|%s|%s|%s|%s|%s|%d",
            seg, text, textColor, font, size, align, effect, bgColor, intensity)
    end

    -- ---------------------------------------------------------------
    -- Initialize
    -- ---------------------------------------------------------------
    local function Initialize()
        print("===========================================")
        print("LED Matrix Complete v3.3.0 Initializing")
        print("===========================================")

        Controls.ip_address.String  = ip_addr
        Controls.udp_port.String    = tostring(udp_port)
        Controls.brightness.Value   = 128
        Controls.last_command.String = "Ready"

        -- Set dropdown Choices at runtime (required by Q-SYS for ComboBox to work)
        Controls.layout.Choices = {"Fullscreen", "Split Vertical", "Split Horizontal", "Quad"}
        Controls.layout.String  = "Fullscreen"

        local colorChoices  = {"White", "Red", "Lime", "Blue", "Yellow", "Magenta", "Cyan",
                               "Orange", "Purple", "Green", "Pink", "Gold", "Silver", "Gray", "Black"}
        local bgChoices     = {"Black", "White", "Red", "Lime", "Blue", "Yellow", "Magenta", "Cyan",
                               "Orange", "Purple", "Green", "Pink", "Gold", "Silver", "Gray"}
        local fontChoices   = {"Arial", "Verdana", "Digital", "Mono"}
        local sizeChoices   = {"auto", "8", "12", "16", "24", "32"}
        local alignChoices  = {"Left", "Center", "Right"}
        local effectChoices = {"none", "scroll", "blink", "fade", "rainbow"}

        local defaultColors = {"White", "Lime", "Red", "Yellow"}
        for seg = 0, 3 do
            local s = tostring(seg)
            Controls["text_color_"..s].Choices  = colorChoices
            Controls["bg_color_"..s].Choices    = bgChoices
            Controls["font_"..s].Choices        = fontChoices
            Controls["size_"..s].Choices        = sizeChoices
            Controls["align_"..s].Choices       = alignChoices
            Controls["effect_"..s].Choices      = effectChoices

            Controls["text_"..s].String         = ""
            Controls["text_color_"..s].String   = defaultColors[seg + 1]
            Controls["bg_color_"..s].String     = "Black"
            Controls["intensity_"..s].Value     = 255
            Controls["font_"..s].String         = "Arial"
            Controls["size_"..s].String         = "auto"
            Controls["align_"..s].String        = "Center"
            Controls["effect_"..s].String       = "none"
            Controls["active_"..s].Boolean      = false
        end

        ReopenSocket()
        print("===========================================")
    end

    -- ---------------------------------------------------------------
    -- Layout handler
    -- ---------------------------------------------------------------
    Controls.apply_layout.EventHandler = function()
        local layoutName = Controls.layout.String
        local config     = LayoutConfigs[layoutName]
        if not config then
            print("✗ Unknown layout: " .. layoutName)
            return
        end
        print("Applying layout: " .. layoutName)

        -- Configure active segments
        for _, cfg in ipairs(config.configs) do
            SendCommand(string.format("CONFIG|segment|%d|x|%d",      cfg.seg, cfg.x))
            SendCommand(string.format("CONFIG|segment|%d|y|%d",      cfg.seg, cfg.y))
            SendCommand(string.format("CONFIG|segment|%d|width|%d",  cfg.seg, cfg.width))
            SendCommand(string.format("CONFIG|segment|%d|height|%d", cfg.seg, cfg.height))
        end

        -- Clear unused segments
        for _, seg in ipairs(config.clears) do
            SendCommand(string.format("CLEAR|%d", seg))
        end

        -- Build active-segment lookup for indicator update
        local activeSet = {}
        for _, s in ipairs(config.activeSegments) do activeSet[s] = true end
        for seg = 0, 3 do
            Controls[string.format("active_%d", seg)].Boolean = activeSet[seg] == true
        end

        -- Re-send non-empty text for active segments after layout settles
        Timer.CallAfter(function()
            for _, seg in ipairs(config.activeSegments) do
                local text, cmd = BuildTextCommand(seg)
                if text ~= "" then SendCommand(cmd) end
            end
        end, 0.3)
    end

    -- ---------------------------------------------------------------
    -- Per-segment send / clear handlers (single loop)
    -- ---------------------------------------------------------------
    for seg = 0, 3 do
        Controls[string.format("send_%d", seg)].EventHandler = function()
            local text, cmd = BuildTextCommand(seg)
            if SendCommand(cmd) then
                Controls[string.format("active_%d", seg)].Boolean = true
            end
        end

        Controls[string.format("clear_%d", seg)].EventHandler = function()
            if SendCommand(string.format("CLEAR|%d", seg)) then
                Controls[string.format("active_%d", seg)].Boolean = false
            end
        end
    end

    -- ---------------------------------------------------------------
    -- Global controls
    -- ---------------------------------------------------------------
    Controls.clear_all.EventHandler = function()
        if SendCommand("CLEAR_ALL") then
            for seg = 0, 3 do
                Controls[string.format("active_%d", seg)].Boolean = false
            end
        end
    end

    Controls.brightness.EventHandler = function(ctl)
        local value = math.floor(ctl.Value)
        Debounce("brightness", 0.5, function()
            SendCommand(string.format("BRIGHTNESS|%d", value))
        end)
    end

    -- ---------------------------------------------------------------
    -- Per-segment intensity (debounced)
    -- ---------------------------------------------------------------
    for seg = 0, 3 do
        Controls[string.format("intensity_%d", seg)].EventHandler = function(ctl)
            local value = math.floor(ctl.Value)
            Debounce("intensity_" .. seg, 0.5, function()
                local text, cmd = BuildTextCommand(seg)
                if text ~= "" then SendCommand(cmd) end
            end)
        end

        -- Auto-send when size or effect changes
        local function AutoSend()
            local text, cmd = BuildTextCommand(seg)
            if text ~= "" then SendCommand(cmd) end
        end
        Controls[string.format("size_%d",   seg)].EventHandler = AutoSend
        Controls[string.format("effect_%d", seg)].EventHandler = AutoSend
    end

    -- ---------------------------------------------------------------
    -- Connection change handlers
    -- ---------------------------------------------------------------
    Controls.ip_address.EventHandler = function(ctl)
        ip_addr = ctl.String
        print("IP address changed to: " .. ip_addr)
        ReopenSocket()
    end

    Controls.udp_port.EventHandler = function(ctl)
        local validated = ValidatePort(ctl.String)
        if validated then
            udp_port = validated
            print("UDP port changed to: " .. udp_port)
            ReopenSocket()
        else
            print("✗ Invalid port number: " .. ctl.String)
            Controls.last_command.String = "ERROR: Invalid port"
        end
    end

    -- ---------------------------------------------------------------
    -- Cleanup
    -- ---------------------------------------------------------------
    function Cleanup()
        print("Cleaning up LED Matrix Controller...")
        for _, t in pairs(debounceTimers) do
            if t then pcall(function() t:Stop() end) end
        end
        if socket then pcall(function() socket:Close() end) end
    end

    Initialize()
end
